# Group Anagrams
https://leetcode.com/problems/group-anagrams/description/

## Train of thought (Finding Anagrams)
In this case, I wanted to figure out how to store unique integer values for each word based on its corresponding 
character composition.

This would mean that each word would generate a unique key based on its character composition. In order to do that,
each letter within the alphabet would have to be assigned with a ***prime number***.

```
a = 'abcdefghijklmnopqrstuvwxyz'
p = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]
d_map = dict(zip(a, p))
```

## Why use prime numbers?

We can use prime numbers to our advantage to save on computational space. Since prime numbers are not divisible by
any number except itself and 1, if we multiply any amount of prime numbers together, we will get a composite number
no matter what.

This ensures that no string composition would overlap with existing prime chacters or other unique strings which is how we can derrive unique keys out of corresponding strings.

```
KEY             VALUE
"aab" = 2*2*3 = 12
No other composition of characters can have the product of 12. Although 4 is a divisor of 12,
since 4 is not a prime number, it cannot possibly overlap with any other chacter value.
```

If we find the total product of each chacter prime value, we can then check to see if the product total aligns with
an existing prime value. In order for two strings to have the same key value, they MUST be anagrams since they are
essentially being multiplied by the same prime numbers.

```
KEY             VALUE
"aab" = 2*2*3 = 12
"aba" = 2*3*2 = 12

Since the value is the same, both "aab" and "aba" must be anagrams.
```
## How does this save computational power?
With this provided, we do not need to check and compare character values of each string anymore which would take O(k^2).
Rather, we can just compute the unique product value of each string and do a quick INT compairson
which would take O(k) time complexity where 'k' is the length of the longest string.

Code would look like this (Python):

```
for word in strs: # loop through all words in the arrsy
  val = 1
  for char in word: # loop through all the characters in each word 
    val *= d_map[char] # find ascii numerical value and sum it up to find val
```

## Applying this with hash maps
Therefore, for each new integer generated by a string, we can store it as a key and the string as its value.

![image](https://github.com/mike-jshen/leetcode/assets/68671792/b8138639-9768-4a07-8c41-d4c901d11603)

For existing integer generated by strings, we append into the array with the appropriate key. 

![image](https://github.com/mike-jshen/leetcode/assets/68671792/da1570f5-03eb-457d-8222-36dcd381a87b)

Visualized image in code form:

```
            if val in a_dic:
                a_dic[val].append(word)
            else:
                a_dic[val] = [word]
```

Finally, we take all the value arrays and put them in a 2D array configuration.

![image](https://github.com/mike-jshen/leetcode/assets/68671792/b86a9d04-32c2-4be5-b948-d37644374445)

Code would look like:
```
        arr = []
        for keys in a_dic:
            arr.append(a_dic[keys])
```

The code would look like: 
```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        a = 'abcdefghijklmnopqrstuvwxyz'
        p = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]
        d_map = dict(zip(a, p))
        
        a_dic = {}

        for word in strs: # loop through all words in the arrsy
            val = 1
            for char in word: # loop through all the characters in each word 
                val *= d_map[char] # find ascii numerical value and sum it up to find val

            if val in a_dic:
                a_dic[val].append(word)
            else:
                a_dic[val] = [word]

        result = []
        for keys in a_dic:
            result.append(a_dic[keys])
        
        return result
```
